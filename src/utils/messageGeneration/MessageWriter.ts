import * as fs from 'fs';
import * as util from 'util';
import IndentedWriter from './IndentedWriter';
import * as fieldsUtil from './fields';
import type { Field } from './fields';
import type { MsgSpec, SrvSpec, ActionSpec } from './MessageSpec';
import type RosMsgSpec from './MessageSpec';

export function createMessageClass(msgSpec: MsgSpec) {
  let w = new IndentedWriter();
  writeHeader(w, msgSpec);
  writeRequires(w, msgSpec, false);
  writeClass(w, msgSpec);
  writeSerialize(w, msgSpec);
  writeDeserialize(w, msgSpec);
  writeGetMessageSize(w, msgSpec);
  writeRosDatatype(w, msgSpec);
  writeMd5sum(w, msgSpec);
  writeMessageDefinition(w, msgSpec);
  writeResolve(w, msgSpec);
  w.dedent('}').newline();
  writeConstants(w, msgSpec);
  w.write(`module.exports = ${msgSpec.messageName}`);

  return w.get();
}

export function createServiceClass(srvSpec: SrvSpec) {
  let w = new IndentedWriter();
  writeHeader(w, srvSpec);
  const { localDeps, foundPackages } = writeRequires(w, srvSpec.request, true);
  writeRequires(w, srvSpec.response, true, foundPackages, localDeps);
  writeServiceComponent(w, srvSpec.request);
  writeServiceComponent(w, srvSpec.response);
  writeServiceEnd(w, srvSpec);

  return w.get();
}

export function generateActionGoalMessage(messageName: string) {
  const w = new IndentedWriter();
  w.write('# ===== DO NOT MODIFY! AUTOGENERATED FROM ACTION DEFINITION =====')
    .write('std_msgs/Header header')
    .write('actionlib_msgs/GoalID goal_id')
    .write(`${messageName}Goal goal`);

  return w.get();
}

export function generateActionResultMessage(messageName: string) {
  const w = new IndentedWriter();
  w.write('# ===== DO NOT MODIFY! AUTOGENERATED FROM ACTION DEFINITION =====')
    .write('std_msgs/Header header')
    .write('actionlib_msgs/GoalStatus status')
    .write(`${messageName}Result result`);

  return w.get();
}

export function generateActionFeedbackMessage(messageName: string) {
  const w = new IndentedWriter();
  w.write('# ===== DO NOT MODIFY! AUTOGENERATED FROM ACTION DEFINITION =====')
    .write('std_msgs/Header header')
    .write('actionlib_msgs/GoalStatus status')
    .write(`${messageName}Feedback feedback`);

  return w.get();
}

export function generateActionMessage(messageName: string) {
  const w = new IndentedWriter();
  w.write('# ===== DO NOT MODIFY! AUTOGENERATED FROM ACTION DEFINITION =====')
    .write(`${messageName}ActionGoal action_goal`)
    .write(`${messageName}ActionResult action_result`)
    .write(`${messageName}ActionFeedback action_feedback`);

  return w.get();
}

function writeHeader(w: IndentedWriter, spec: RosMsgSpec) {
  w.dividingLine();
  w.write('// Auto-generated from package %s.', spec.packageName);
  w.write('// !! Do not edit !!');
  w.dividingLine();
  w.newline();
}

function writeRequires(w: IndentedWriter, spec: MsgSpec, isSrv: boolean, previousPackages:Set<string>|null=null, previousDeps:Set<string>|null=null) {
  if (previousPackages === null) {
    w.write('"use strict";');
    w.newline();
    w.write('const _serializer = _ros_msg_utils.Serialize;');
    w.write('const _arraySerializer = _serializer.Array;');
    w.write('const _deserializer = _ros_msg_utils.Deserialize;');
    w.write('const _arrayDeserializer = _deserializer.Array');
    w.write('const _finder = _ros_msg_utils.Find;');
    w.write('const _getByteLength = _ros_msg_utils.getByteLength');
    previousPackages = new Set();
  }
  if (previousDeps === null) {
    previousDeps = new Set();
  }

  const packageName = spec.packageName;
  // a unique list of package-local dependencies on other messages
  const localDeps: Set<string> = new Set();
  // a unique list of other package dependencies
  const foundPackages: Set<string> = new Set();

  spec.fields.forEach((field: Field) => {
    if (!field.isBuiltin) {
      const fieldPack = field.getPackage();
      if (fieldPack === packageName) {
        const fieldMsgType = field.getMessage();
        // don't require this type again
        if (!previousDeps.has(fieldMsgType) && !localDeps.has(fieldMsgType)) {
          localDeps.add(fieldMsgType);
          if (isSrv) {
            w.write('import * as %s from \'../msg/%s.js\');', fieldMsgType, fieldMsgType);
          } else {
            w.write('import * as %s from \'./%s.js\');', fieldMsgType, fieldMsgType);
          }
        }
      }
      else {
        // don't find this package again
        if (!previousPackages.has(fieldPack) && !foundPackages.has(fieldPack)) {
          foundPackages.add(fieldPack);
          w.write('const %s = _finder(\'%s\');', fieldPack, fieldPack);
        }
      }
    }
  });

  w.newline();
  w.dividingLine();
  w.newline();
  return {localDeps, foundPackages};
}

function getMessagePathFromField(field: Field, packageName: string): string {
  const [fieldPackage, fieldMsg] = field.baseType.split('/');
  if (fieldPackage === packageName) {
    return util.format('%s', fieldMsg);
  }
  // else
  return util.format('%s.msg.%s', fieldPackage, fieldMsg);
}

function getDefaultValue(field: Field, packageName: string): any {
  if (field.isArray) {
    if (!field.arrayLen) {
      return '[]';
    }
    else {
      let fieldCopy = Object.assign({}, field);
      fieldCopy.isArray = false;
      let fieldDefault = getDefaultValue(fieldCopy, packageName);
      return util.format('new Array(%s).fill(%s)', field.arrayLen, fieldDefault);
    }
  }
  else if (field.isBuiltin) {
    if (fieldsUtil.isString(field.type)) {
      return '\'\'';
    } else if (fieldsUtil.isTime(field.type)) {
      return '{secs: 0, nsecs: 0}';
    } else if (fieldsUtil.isBool(field.type)) {
      return 'false';
    } else if (fieldsUtil.isFloat(field.type)) {
      return '0.0'
    }
    // else is int
    return '0';
  }
  // else
  return `new ${getMessagePathFromField(field, packageName)}()`;
}

function writeMsgConstructorField(w: IndentedWriter, spec: MsgSpec, field: Field) {
  w.write('if (initObj.hasOwnProperty(\'%s\')) {', field.name).indent();
  w.write('this.%s = initObj.%s;', field.name, field.name).dedent();
  w.write('}');
  w.write('else {').indent();
  w.write('this.%s = %s;', field.name, getDefaultValue(field, spec.packageName)).dedent();
  w.write('}');
  w.newline();
}

function writeClass(w: IndentedWriter, spec: MsgSpec) {
  w.write('class %s {', spec.messageName);
  w.indent();
  w.write('constructor(initObj={}) {');
  w.indent('if (initObj === null) {')
    .indent('// initObj === null is a special case for deserialization where we don\'t initialize fields');
  spec.fields.forEach((field: Field) => {
    w.write('this.%s = null;', field.name);
  });
  w.dedent('}')
    .write('else {')
    .indent('// check for this message\'s fields by key name - otherwise assign default values');
  spec.fields.forEach((field: Field) => {
    writeMsgConstructorField(w, spec, field);
  });
  w.dedent('}')
    .dedent('}')
    .newline();
}

function writeResolve(w: IndentedWriter, spec: MsgSpec) {
  // this borrows a lot from the constructor but I'm worried about passing in
  // a second argument to the constructor (e.g. constructor(json, forceResolve)) and
  // then in the future we're hosed if we want to accept in-order arguments
  w.write('static Resolve(msg) {')
    .indent('// deep-construct a valid message object instance of whatever was passed in')
    .write('if (typeof msg !== \'object\' || msg === null) {')
    .indent('msg = {};')
    .dedent('}')
    .write(`const resolved = new ${spec.messageName}(null);`);
  spec.fields.forEach((field: Field) => {
    if (!field.isBuiltin) {
      w.write(`if (msg.${field.name} !== undefined) {`)
        .indent();
      if (field.isArray) {
        if (field.arrayLen === null) {
          w.write(`resolved.${field.name} = new Array(msg.${field.name}.length);`)
            .write(`for (let i = 0; i < resolved.${field.name}.length; ++i) {`)
            .indent(`resolved.${field.name}[i] = ${getMessagePathFromField(field, spec.packageName)}.Resolve(msg.${field.name}[i]);`)
            .dedent('}')
        }
        else {
          w.write(`resolved.${field.name} = new Array(${field.arrayLen});`)
            .write(`for (let i = 0; i < resolved.${field.name}.length; ++i) {`)
            .indent(`if (msg.${field.name}.length > i) {`)
            .indent(`resolved.${field.name}[i] = ${getMessagePathFromField(field, spec.packageName)}.Resolve(msg.${field.name}[i]);`)
            .dedent('}')
            .write('else {')
            .indent(`resolved.${field.name}[i] = new ${getMessagePathFromField(field, spec.packageName)}();`)
            .dedent('}')
            .dedent('}');
        }
      }
      else {
        w.write(`resolved.${field.name} = ${getMessagePathFromField(field, spec.packageName)}.Resolve(msg.${field.name});`);
      }

      w.dedent('}')
        .write('else {') // msg.fieldName === undefined
        .indent(`resolved.${field.name} = ${getDefaultValue(field, spec.packageName)};`)
        .dedent('}')
    }
    else {
      w.write(`if (msg.${field.name} !== undefined) {`)
        .indent(`resolved.${field.name} = msg.${field.name};`)
        .dedent('}')
        .write('else {')
        .indent(`resolved.${field.name} = ${getDefaultValue(field, spec.packageName)};`)
        .dedent('}');
    }

    w.newline();
  });
  w.write('return resolved;')
   .dedent('}');
}

function writeSerializeLength(w: IndentedWriter, name: string): void {
  w.write(`// Serialize the length for message field [${name}]`)
    .write(`bufferOffset = _serializer.uint32(obj.${name}.length, buffer, bufferOffset);`);
}

function writeSerializeLengthCheck(w: IndentedWriter, field: Field): void {
  w.write(`// Check that the constant length array field [${field.name}] has the right length`)
    .write(`if (obj.${field.name}.length !== ${field.arrayLen}) {`)
    .indent()
    .write(`throw new Error(\'Unable to serialize array field ${field.name} - length must be ${field.arrayLen}\')`)
    .dedent()
    .write('}');
}

function writeSerializeBuiltinField(w: IndentedWriter, f: any): void {
  if (f.isArray) {
    w.write(`bufferOffset = _arraySerializer.${f.baseType}(obj.${f.name}, buffer, bufferOffset, ${f.arrayLen});`);
  }
  else {
    w.write(`bufferOffset = _serializer.${f.baseType}(obj.${f.name}, buffer, bufferOffset);`);
  }
}

function writeSerializeMessageField(w: IndentedWriter, f: any, thisPackage: string): void {
  let fieldPackage = fieldsUtil.getPackageNameFromMessageType(f.baseType);
  let msgName = fieldsUtil.getMessageNameFromMessageType(f.baseType);
  let samePackage = (fieldPackage === thisPackage);
  if (f.isArray) {
    if (!f.arrayLen) {
      writeSerializeLength(w, f.name);
    }
    w.write(`obj.${f.name}.forEach((val) => {`)
      .indent();
    if (samePackage) {
      w.write(`bufferOffset = ${msgName}.serialize(val, buffer, bufferOffset);`);
    }
    else {
      w.write(`bufferOffset = ${fieldPackage}.msg.${msgName}.serialize(val, buffer, bufferOffset);`);
    }
    w.dedent()
      .write('});');
  }
  else {
    if (samePackage) {
      w.write(`bufferOffset = ${msgName}.serialize(obj.${f.name}, buffer, bufferOffset);`);
    }
    else {
      w.write(`bufferOffset = ${fieldPackage}.msg.${msgName}.serialize(obj.${f.name}, buffer, bufferOffset);`);
    }
  }
}

function writeSerializeField(w: IndentedWriter, field: Field, packageName: string): void {
  if (field.isArray) {
    if (field.arrayLen) {
      writeSerializeLengthCheck(w, field);
    }
    w.newline();
  }
  w.write('// Serialize message field [%s]', field.name);
  if (field.isBuiltin) {
    writeSerializeBuiltinField(w, field);
  }
  else {
    writeSerializeMessageField(w, field, packageName);
  }
  w.newline();
}

function writeSerialize(w: IndentedWriter, spec: MsgSpec): void {
  w.write('static serialize(obj, buffer, bufferOffset) {')
    .indent()
    .write('// Serializes a message object of type %s', spec.messageName);
  spec.fields.forEach((field: Field) => {
    writeSerializeField(w, field, spec.packageName);
  });
  w.write('return bufferOffset;')
    .dedent()
    .write('}')
    .newline();
}

function writeDeserializeLength(w: IndentedWriter, name: string): void {
  w.write(`// Deserialize array length for message field [${name}]`);
  w.write('len = _deserializer.uint32(buffer, bufferOffset);')
}

function writeDeserializeMessageField(w: IndentedWriter, field: Field, thisPackage: string): void {
  const fieldPackage = fieldsUtil.getPackageNameFromMessageType(field.baseType);
  const msgName = fieldsUtil.getMessageNameFromMessageType(field.baseType);
  const samePackage = (fieldPackage === thisPackage);
  if (field.isArray) {
    // only create a new array if it has a non-constant length
    if (!field.arrayLen) {
      writeDeserializeLength(w, field.name);
    }
    else {
      w.write(`len = ${field.arrayLen};`);
    }

    w.write(`data.${field.name} = new Array(len);`)
     .write('for (let i = 0; i < len; ++i) {')
      .indent();
    if (samePackage) {
      w.write(`data.${field.name}[i] = ${msgName}.deserialize(buffer, bufferOffset);`);
    }
    else {
      w.write(`data.${field.name}[i] = ${fieldPackage}.msg.${msgName}.deserialize(buffer, bufferOffset);`);
    }
    w.dedent('}');
  }
  else {
    if (samePackage) {
      w.write(`data.${field.name} = ${msgName}.deserialize(buffer, bufferOffset);`);
    }
    else {
      w.write(`data.${field.name} = ${fieldPackage}.msg.${msgName}.deserialize(buffer, bufferOffset);`);
    }
  }
}

function writeDeserializeBuiltinField(w: IndentedWriter, field: Field): void {
  if (field.isArray) {
    w.write(`data.${field.name} = _arrayDeserializer.${field.baseType}(buffer, bufferOffset, ${field.arrayLen});`);
  }
  else {
    w.write(`data.${field.name} = _deserializer.${field.baseType}(buffer, bufferOffset);`);
  }
}

function writeDeserializeField(w: IndentedWriter, field: Field, packageName: string): void {
  w.write(`// Deserialize message field [${field.name}]`);
  if (field.isBuiltin) {
    writeDeserializeBuiltinField(w, field);
  }
  else {
    writeDeserializeMessageField(w, field, packageName);
  }
  w.newline()
}

function writeDeserialize(w: IndentedWriter, spec: MsgSpec): void {
  w.write('static deserialize(buffer, bufferOffset=[0]) {')
    .indent('// Deserializes a message object of type %s', spec.messageName)
    .write('let data = new %s(null);', spec.messageName)
    .write('let len;');
  spec.fields.forEach((field: Field) => {
    writeDeserializeField(w, field, spec.packageName);
  });
  w.write('return data;')
    .dedent()
    .write('}')
    .newline();
}

function getTypeSize(t: string): number|null {
  switch(t) {
    case 'int8':
    case 'uint8':
    case 'byte':
    case 'bool':
    case 'char':
      return 1;
    case 'int16':
    case 'uint16':
      return 2;
    case 'int32':
    case 'uint32':
    case 'float32':
      return 4;
    case 'int64':
    case 'uint64':
    case 'float64':
    case 'time':
    case 'duration':
      return 8;
  }
  return null;
}

function writeGetMessageSize(w: IndentedWriter, spec: MsgSpec): void {
  // Write a static method to determine the buffer size of a complete message
  w.write('static getMessageSize(object) {');
  const msgSize = spec.getMessageFixedSize();
  if (msgSize !== null) {
    w.indent()
      .write(`return ${msgSize};`)
  }
  else {
    w.indent()
      .write('let length = 0;');

    // certain fields will always have the same size
    // calculate that here instead of dynamically every time
    let lenConstantLengthFields = 0;
    spec.fields.forEach((field: Field) => {
      let fieldSize = 0;
      if (field.isBuiltin) {
        fieldSize = getTypeSize(field.baseType);
      }
      else {
        const fieldSpec = spec.getMsgSpecForType(field.baseType);
        if (!fieldSpec) {
          spec.getMsgSpecForType(field.baseType);
        }
        fieldSize = fieldSpec.getMessageFixedSize();
      }

      if (field.isArray) {
        if (field.arrayLen && fieldSize !== null) {
          lenConstantLengthFields += fieldSize * field.arrayLen;
          return;
        }
        else if (field.arrayLen === null) {
          // account for 4 byte array length
          lenConstantLengthFields += 4;
        }

        if (fieldSize === 1) {
          w.write(`length += object.${field.name}.length;`);
        }
        else if (fieldSize !== null) {
          w.write(`length += ${fieldSize} * object.${field.name}.length`);
        }
        else {
          let lineToWrite;
          if (field.isBuiltin) {
            if (!fieldsUtil.isString(field.baseType)) {
              throw new Error(`Unexpected field ${field.name} with type ${field.baseType} has unknown length`);
            }

            // it's a string array!
            lineToWrite = `length += 4 + _getByteLength(object.${field.name}[i]);`;
          }
          else {
            const [pkg, msgType] = field.baseType.split('/');
            const samePackage = (spec.packageName === pkg);
            if (samePackage) {
              lineToWrite = `length += ${msgType}.getMessageSize(object.${field.name}[i]);`;
            }
            else {
              lineToWrite = `length += ${pkg}.msg.${msgType}.getMessageSize(object.${field.name}[i]);`;
            }
          }

          w.write(`for(let i = 0; i < object.${field.name}.length; ++i) {`)
            .indent()
            .write(lineToWrite)
            .dedent()
            .write('}');
        }
      }
      else if (fieldSize !== null) {
        lenConstantLengthFields += fieldSize;
      }
      else {
        let lineToWrite;
        // field size is variable *blurgh blurgh*
        if (field.isBuiltin) {
          if (!fieldsUtil.isString(field.baseType)) {
            throw new Error(`Unexpected field ${field.name} with type ${field.baseType} has unknown length`);
          }
          // it's a string!
          // string length consumes 4 bytes in message
          lenConstantLengthFields += 4;
          lineToWrite = `length += _getByteLength(object.${field.name});`
        }
        else {
          const [pkg, msgType] = field.baseType.split('/');
          const samePackage = (spec.packageName === pkg);
          if (samePackage) {
            lineToWrite = `length += ${msgType}.getMessageSize(object.${field.name})`;
          }
          else {
            lineToWrite = `length += ${pkg}.msg.${msgType}.getMessageSize(object.${field.name})`;
          }
        }
        w.write(lineToWrite);
      }
    });

    if (lenConstantLengthFields > 0) {
      w.write(`// ${lenConstantLengthFields} is precalculated sum of the constant length fields`);
      w.write(`return length + ${lenConstantLengthFields};`);
    }
    else {
      w.write('return length;');
    }
  }
  w.dedent()
    .write('}')
    .newline()
}

function writeRosDatatype(w: IndentedWriter, spec: MsgSpec) {
  w.write('static datatype() {')
    .indent(`// Returns string type for a ${spec.getFullMessageName()} object`)
    .write(`return '${spec.getFullMessageName()}';`)
    .dedent('}')
    .newline()
}

function writeMd5sum(w: IndentedWriter, spec: MsgSpec) {
  w.write('static md5sum() {')
    .indent('// Returns md5sum of message object')
    .write(`return '${spec.getMd5sum()}'`)
    .dedent('}')
    .newline()
}

function writeMessageDefinition(w: IndentedWriter, spec: MsgSpec) {
  w.write('static messageDefinition() {')
    .indent('// Returns full string definition for message')
    .write('return `');

  const fullText = spec.computeFullText();
  w.write(`${fullText}\n\`;`)
    .dedent('}')
    .newline();
}

function writeConstants(w: IndentedWriter, spec: MsgSpec) {
  if (spec.constants && spec.constants.length > 0) {
    w.write('// Constants for message')
      .write(`${spec.messageName}.Constants = {`)
      .indent();
    spec.constants.forEach((constant) => {
      if (fieldsUtil.isString(constant.type)) {
        w.write(`${constant.name.toUpperCase()}: '${constant.value}',`);
      }
      else {
        w.write(`${constant.name.toUpperCase()}: ${constant.value},`);
      }
    });
    w.dedent('}')
      .newline()
  }
}

function writeServiceComponent(w: IndentedWriter, spec: MsgSpec) {
  writeClass(w, spec);
  writeSerialize(w, spec);
  writeDeserialize(w, spec);
  writeGetMessageSize(w, spec);
  writeRosDatatype(w, spec);
  writeMd5sum(w, spec);
  writeMessageDefinition(w, spec);
  writeResolve(w, spec);
  w.dedent('}').newline();
  writeConstants(w, spec);
  w.dividingLine();
}

function writeServiceEnd(w: IndentedWriter, spec: SrvSpec) {
  w.write('module.exports = {')
    .indent(`Request: ${spec.request.messageName},`)
    .write(`Response: ${spec.response.messageName},`)
    .write(`md5sum() { return '${spec.getMd5sum()}'; },`)
    .write(`datatype() { return '${spec.getFullMessageName()}'; }`)
    .dedent('};')
    .newline();
}
